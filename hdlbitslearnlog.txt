
/*
这个例子还是挺有意思的。256到1筛选器。sel指定要输出的in数据中的哪一段。输出4位宽的数据。
在选择给out赋值的时候，使用不了selx4这样的表达式，会报错
下面是系统提示的要点
With this many options, a case statement isn't so useful.
Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. 
It's not always good at this. An error saying "... is not a constant" means it couldn't prove that the select width is constant. 
In particular, in[ sel*4+3 : sel*4 ] does not work.
Bit slicing ("Indexed vector part select", since Verilog-2001) has an even more compact syntax

最终使用generate for给out赋值
不使用generate for,有如下错误
Error (10170): Verilog HDL syntax error at top_module.v(20) near text: "for";  expecting "endmodule". 
*/
module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    reg [1023:0] inbuf;
    reg [7:0] selbuf;
    
    always @ (*) begin
        inbuf = in;
        selbuf = sel;
    end
    
    genvar i;
    integer j;
    always @ (*) begin
    j = selbuf*4;
    end
    generate for ( i=0; i<4; i=i+1 ) begin:ll
        assign out[i] = inbuf[j+i];
    end
        endgenerate
        
endmodule


/*
if else成对出现安全
case 要有default

变量要赋初值
*/

module top_module( 
    input [3:0] in,
    output [2:0] out_both,
    output [3:1] out_any,
    output [3:0] out_different );

    reg [2:0] bothbuf={3{1'b0}};//变量要赋初值
    reg [3:1] anybuf={3{1'b0}};//变量要赋初值
    reg [3:0] diffbuf={4{1'b0}};//变量要赋初值
    
    integer i;
    always @ (*) begin
        
        for ( i=0;i<3; i=i+1 ) begin
            if ((i<=2)&&( in[i]&in[i+1] == 1 )) bothbuf[i] = 1;
            else bothbuf[i] = 0;
            if (( in[3-i]|in[2-i] == 1)&& (i<=2 )) anybuf[3-i] = 1;
            else anybuf[3-i] = 0;
            if (( in[i]^in[i+1] == 1)&&(i<3)) diffbuf[i]=1;
            else  diffbuf[i]=0;
           end
        if ( in[3]^in[0] == 1) diffbuf[i]=1;
        else  diffbuf[i]=0;
    end
    
    assign out_both = bothbuf;
    assign out_any = anybuf;
    assign out_different = diffbuf;
endmodule


/*
卡诺图
canonical form
相邻的可以合并成一项

X2X1	00	01	11	10
X3				
0			1	1
1		1	1	
				
				
				
				
	F1=~X3X2X1+(~X3)X2(~X1)=~X3X2			
	F2=X3(~X2)X1+X3X2X1=X3X1			
	F=F1+F2			
*/

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    //assign f = (x2&x1)|(x3&x1)|(~x3&x2);
    assign f = (x3&x1)|(~x3&x2);
endmodule

/*
X1X0	00	01	11	10
X3X2				
00		1			
01			1		
11				1	
10					1
				
				
	F=(~X3~X2~X1~X0)+(~X3X2~X1X0)+(X3X2X1X0)+X3~X2X1~X0			

*/

module top_module ( input [1:0] A, input [1:0] B, output z ); 

    assign z=((~A[1])&(~A[0])&(~B[1])&(~B[0]))|((~A[1])&(A[0])&(~B[1])&(B[0]))|
        ((A[1])&(~A[0])&(B[1])&(~B[0]))|((A[1])&(A[0])&(B[1])&(B[0]));
endmodule



/*
端口接地或者电源等不会发生变化的情况
*/
module top_module (
    output out);
    reg x;
    
	assign out = x&~x;
endmodule


/*
已知给出如下bcd 4位加法模块定义如下
module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );

要求计算的数据如下
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

解决：
1 使用generate 相关的语句实现。以避免写100个实例化的语句
2 generate for 
begin后面接 : 然后是label定义
定义模块不用使用实例化的写法，如声明一般，输入直接写带入计算的端口定义，输出要确保每个实例化的输出端不能连在一起，如本例子中，需要增加cinbuf【100】
coutbuf【99】
3 除了第2点，cinbuf coutbuf等操作，可以使用always

*/
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    reg [100:0] cinbuf;
    reg [99:0] coutbuf;
	genvar i;   
    always @ (*) begin
        cinbuf[0] = cin;
    end
    generate for (i=0; i<397; i=i+4 ) begin: bcd
        bcd_fadd bh(a[i+3:i],b[i+3:i],cinbuf[i/4+i%4],coutbuf[i/4+i%4],sum[i+3:i]);
        always @ (*) begin
            cinbuf[i/4+i%4+1] = coutbuf[i/4+i%4];
        end
                        end
                        endgenerate
//      end
    assign cout = coutbuf[99];                  
endmodule
